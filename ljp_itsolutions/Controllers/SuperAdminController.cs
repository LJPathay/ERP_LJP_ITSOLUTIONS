using Microsoft.AspNetCore.Mvc;
using ljp_itsolutions.Services;
using ljp_itsolutions.Models;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Authorization;
using Microsoft.EntityFrameworkCore;
using System.Text.Json;
using System.Security.Claims;

namespace ljp_itsolutions.Controllers
{
    [Authorize(Roles = UserRoles.SuperAdmin)]
    public class SuperAdminController : BaseController
    {
        private readonly InMemoryStore _store;
        private readonly IPasswordHasher<ljp_itsolutions.Models.User> _hasher;
        private readonly IReceiptService _receiptService;
        private readonly IServiceScopeFactory _scopeFactory;
        private readonly IAnalyticsService _analyticsService;

        public SuperAdminController(InMemoryStore store, ljp_itsolutions.Data.ApplicationDbContext db, IPasswordHasher<ljp_itsolutions.Models.User> hasher, IReceiptService receiptService, IServiceScopeFactory scopeFactory, IAnalyticsService analyticsService)
            : base(db)
        {
            _store = store;
            _hasher = hasher;
            _receiptService = receiptService;
            _scopeFactory = scopeFactory;
            _analyticsService = analyticsService;
        }



        public async Task<IActionResult> Dashboard()
        {
            var data = await _analyticsService.GetSuperAdminDashboardDataAsync();
            return View(data);
        }


        // --- User Management ---
        public IActionResult Users(bool showArchived = false)
        {
            var query = _db.Users.AsQueryable();
            if (showArchived) query = query.Where(u => !u.IsActive);
            else query = query.Where(u => u.IsActive);

            var users = query.OrderByDescending(u => u.CreatedAt).ToList();
            
            // Excluded Superadmin role in adding a user in superadmin as an superadmin can add another superadmin???
            ViewBag.Roles = new List<string> { 
                UserRoles.Admin, 
                UserRoles.Manager, 
                UserRoles.Cashier, 
                UserRoles.MarketingStaff 
            };
            
            ViewBag.ShowArchived = showArchived;
            return View(users);
        }

        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> CreateUser([FromBody] User user)
        {
            if (string.IsNullOrEmpty(user.Username))
                return BadRequest("Username is required.");

            if (_db.Users.Any(u => u.Username == user.Username))
            {
                return BadRequest("Username already exists.");
            }

            // SECURITY: Prevent creating another SuperAdmin
            if (user.Role == UserRoles.SuperAdmin)
            {
                return Forbid("Unauthorized role assignment.");
            }

            user.UserID = Guid.NewGuid();
            
            if (!string.IsNullOrEmpty(user.Password))
            {
                user.Password = _hasher.HashPassword(user, user.Password);
            }
            else
            {
                user.Password = _hasher.HashPassword(user, "Default123!");
            }

            user.CreatedAt = DateTime.UtcNow;
            user.IsActive = true;

            _db.Users.Add(user);
            await _db.SaveChangesAsync();

            await LogAudit($"Created user: {user.Username} as {user.Role}", $"Target User ID: {user.UserID}");
            
            return Ok();
        }

        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> EditUser(User updatedUser)
        {
            var user = await _db.Users.FindAsync(updatedUser.UserID);
            if (user == null) return NotFound();

            if (user.Role == UserRoles.SuperAdmin || updatedUser.Role == UserRoles.SuperAdmin)
            {
                TempData["Error"] = "Restricted access: SuperAdmin accounts cannot be modified here.";
                return RedirectToAction("Users");
            }

            user.FullName = updatedUser.FullName;
            user.Username = updatedUser.Username;
            user.Email = updatedUser.Email;
            user.Role = updatedUser.Role;
            user.IsActive = updatedUser.IsActive;
            await _db.SaveChangesAsync();
            await LogAudit($"Updated user: {user.Username}", $"Target User ID: {user.UserID}");
            TempData["Success"] = "User updated successfully.";
            return RedirectToAction("Users");
        }

        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> ArchiveUser(string id)
        {
            if (!Guid.TryParse(id, out var guid)) return RedirectToAction("Users");
            
            var user = await _db.Users.FindAsync(guid);
            if (user != null)
            {
                if (user.Role == UserRoles.SuperAdmin)
                {
                    TempData["Error"] = "SuperAdmin accounts cannot be archived.";
                    return RedirectToAction("Users");
                }

                var archivedUser = new ArchivedUser
                {
                    OriginalUserID = user.UserID,
                    Username = user.Username,
                    FullName = user.FullName,
                    Email = user.Email ?? "",
                    Role = user.Role,
                    ArchivedAt = DateTime.UtcNow,
                    Reason = "User requested archive"
                };

                _db.ArchivedUsers.Add(archivedUser);
                _db.Users.Remove(user);
                
                await _db.SaveChangesAsync();
                await LogAudit($"Archived user: {user.Username}", $"Target User ID: {user.UserID}");
                TempData["Success"] = "User moved to archives successfully.";
            }
            return RedirectToAction("Users");
        }

        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> RestoreUser(string id)
        {
            if (!Guid.TryParse(id, out var guid)) return RedirectToAction("Users");
            var user = await _db.Users.FindAsync(guid);
            if (user != null)
            {
                user.IsActive = true;
                await _db.SaveChangesAsync();
                await LogAudit($"Restored user: {user.Username}", $"Target User ID: {user.UserID}");
                TempData["Success"] = "User restored successfully.";
            }
            return RedirectToAction("Users", new { showArchived = true });
        }

        // --- Audit Logs ---
        public IActionResult AuditLogs()
        {
            var logs = _db.AuditLogs.Include(a => a.User).OrderByDescending(a => a.Timestamp).ToList();
            ViewBag.Users = _db.Users.OrderBy(u => u.FullName).Select(u => new { u.UserID, u.FullName }).ToList();
            return View(logs);
        }

        // --- System Settings ---
        public IActionResult SystemSettings()
        {
            var settings = _db.SystemSettings.ToDictionary(s => s.SettingKey, s => s.SettingValue);
            return View(settings);
        }

        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> UpdateSettings(IFormCollection form)
        {
            try {
                var keys = new[] { 
                    "SystemName", "Timezone", "Currency", "DateFormat", 
                    "SessionTimeout", "PasswordMinLength", "RequireSpecialChars", "RequireNumbers", "TwoFactorAuth",
                    "CompanyName", "TaxRate", "LowStockThreshold", "BusinessHourStart", "BusinessHourEnd",
                    "SmtpServer", "SmtpPort", "EmailNotifications", "LowStockAlerts", "DailyReports",
                    "MaintenanceMode", "LogRetentionDays", "AllowPublicRegistration"
                };
                foreach (var key in keys) {
                    string value = form.ContainsKey(key) ? form[key].ToString() : "";
                    bool isCheckbox = key.Contains("Require") || key.Contains("TwoFactor") || key.Contains("Notifications") || key.Contains("Alerts") || key.Contains("DailyReports");
                    if (isCheckbox)
                        value = (!string.IsNullOrEmpty(value) && (value.ToLower() == "true" || value.ToLower() == "on")) ? "true" : "false";

                    var setting = await _db.SystemSettings.FirstOrDefaultAsync(s => s.SettingKey == key);
                    if (setting == null) {
                        setting = new SystemSetting { SettingKey = key, SettingValue = value };
                        _db.SystemSettings.Add(setting);
                    } else setting.SettingValue = value;
                }
                await _db.SaveChangesAsync();
                await LogAudit("Updated system settings");
                TempData["Success"] = "Settings updated.";
            } catch (Exception ex) { TempData["Error"] = ex.Message; }
            return RedirectToAction("SystemSettings");
        }

        // --- Backups ---
        public IActionResult Backups()
        {
            var path = Path.Combine(Directory.GetCurrentDirectory(), "Backups");
            if (!Directory.Exists(path)) Directory.CreateDirectory(path);
            var files = Directory.GetFiles(path, "*.json").Select(f => new FileInfo(f)).OrderByDescending(f => f.CreationTime).ToList();
            return View(files);
        }

        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> CreateBackup()
        {
            try {
                var path = Path.Combine(Directory.GetCurrentDirectory(), "Backups");
                if (!Directory.Exists(path)) Directory.CreateDirectory(path);
                var fileName = $"backup_{DateTime.UtcNow:yyyyMMdd_HHmmss}.json";
                var fullPath = Path.Combine(path, fileName);
                var backupData = new {
                    GeneratedAt = DateTime.UtcNow,
                    Users = await _db.Users.AsNoTracking().ToListAsync(),
                    Products = await _db.Products.AsNoTracking().ToListAsync(),
                    Orders = await _db.Orders.AsNoTracking().Include(o => o.OrderDetails).ToListAsync(),
                    Settings = await _db.SystemSettings.AsNoTracking().ToListAsync()
                };
                var json = JsonSerializer.Serialize(backupData, new JsonSerializerOptions { WriteIndented = true, ReferenceHandler = System.Text.Json.Serialization.ReferenceHandler.IgnoreCycles });
                await System.IO.File.WriteAllTextAsync(fullPath, json);
                await LogAudit("Created system backup");
                TempData["Success"] = "Backup created.";
            } catch (Exception ex) { TempData["Error"] = ex.Message; }
            return RedirectToAction("Backups");
        }

        [HttpGet]
        public IActionResult DownloadBackup(string fileName)
        {
            if (string.IsNullOrEmpty(fileName)) return BadRequest();
            var path = Path.Combine(Directory.GetCurrentDirectory(), "Backups", fileName);
            if (!System.IO.File.Exists(path)) return NotFound();

            var bytes = System.IO.File.ReadAllBytes(path);
            return File(bytes, "application/json", fileName);
        }

        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> DeleteBackup(string fileName)
        {
            if (string.IsNullOrEmpty(fileName)) return BadRequest();
            var path = Path.Combine(Directory.GetCurrentDirectory(), "Backups", fileName);
            if (System.IO.File.Exists(path))
            {
                System.IO.File.Delete(path);
                await LogAudit($"Deleted backup snapshot: {fileName}");
                TempData["Success"] = "Snapshot deleted successfully.";
            }
            return RedirectToAction("Backups");
        }
    }
}
